#include "MemLoadDriver.h"

#include <dbghelp.h>

#pragma comment(lib, "Dbghelp.lib")

#define CONVERT_RVA(base, offset) ((PVOID)((PUCHAR)(base) + (ULONG)(offset)))

// 加载文件到内存
PVOID LoadFileToMemory(const wchar_t* filePath, size_t& fileBufferLen)
{
    HANDLE hFile = CreateFile(
        filePath,               // 文件路径
        GENERIC_READ,           // 访问权限：只读
        0,                      // 共享模式：该文件不能被其他程序访问
        NULL,                   // 安全属性
        OPEN_EXISTING,          // 打开方式：已存在的文件
        FILE_ATTRIBUTE_NORMAL,  // 文件属性
        NULL                    // 模板文件句柄
    );
    if (INVALID_HANDLE_VALUE == hFile) {
        LOG("CreateFile failed");
        return NULL;
    }

    DWORD fileSize = GetFileSize(hFile, NULL);
    if (INVALID_FILE_SIZE == fileSize)
    {
        LOG("GetFileSize failed");
        CloseHandle(hFile);
        return NULL;
    }

    PVOID pFileBuffer = malloc(fileSize);
    if (NULL == pFileBuffer)
    {
        LOG("malloc failed");
        CloseHandle(hFile);
        return NULL;
    }

    DWORD readedSize = 0;
    if (!ReadFile(hFile, pFileBuffer, fileSize, &readedSize, NULL) || fileSize != readedSize)
    {
        LOG("ReadFile failed");
        free(pFileBuffer);
        CloseHandle(hFile);
        return NULL;
    }

    fileBufferLen = fileSize;

    CloseHandle(hFile);
    return pFileBuffer;
}

// 修复重定位表
bool FixRelocation(PVOID pImageBuffer, PVOID pBaseAddress)
{
    PIMAGE_NT_HEADERS pImageNtHeaders = ImageNtHeader(pImageBuffer);
    if (NULL == pImageNtHeaders)
    {
        LOG("RtlImageNtHeader failed");
        return false;
    }
    ULONG_PTR llDelta = (ULONG_PTR)pBaseAddress - pImageNtHeaders->OptionalHeader.ImageBase;
    PIMAGE_BASE_RELOCATION pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)CONVERT_RVA(pImageBuffer, pImageNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
    ULONG size = pImageNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
    for (ULONG i = 0; i < size; i += pImageBaseRelocation->SizeOfBlock, pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)pImageBaseRelocation + pImageBaseRelocation->SizeOfBlock))
    {
        for (PUSHORT chains = (PUSHORT)((ULONG_PTR)pImageBaseRelocation + sizeof(IMAGE_BASE_RELOCATION)); chains < (PUSHORT)((ULONG_PTR)pImageBaseRelocation + pImageBaseRelocation->SizeOfBlock); ++chains)
        {
            switch (*chains >> 12)
            {
            case IMAGE_REL_BASED_ABSOLUTE:
            {
                break;
            }
            case IMAGE_REL_BASED_HIGHLOW:
            {
                *(PULONG)CONVERT_RVA(pImageBuffer, pImageBaseRelocation->VirtualAddress + (*chains & 0x0fff)) += (ULONG)llDelta;
                break;
            }
            case IMAGE_REL_BASED_DIR64:
            {
                *(PULONG_PTR)CONVERT_RVA(pImageBuffer, pImageBaseRelocation->VirtualAddress + (*chains & 0x0fff)) += llDelta;
                break;
            }
            default:
            {
                LOG("unknown type");
                return false;
            }
            }
        }
    }
    return true;
}

// 通过驱动的导出函数名获取函数地址
PVOID GetDriverExportFuncByName(PVOID pImageAddr, const char* exportFuncName)
{
    // 获取驱动模块的大小imageSize
    MapMemInfo imageMap;
    if (!DBK_MdlMapMem(imageMap, 0, 0, (UINT64)pImageAddr, 0x1000))
    {
        LOG("DBK_MapMem failed");
        return NULL;
    }
    PIMAGE_NT_HEADERS pImageNtHeaders = ImageNtHeader((PVOID)imageMap.address);
    if (NULL == pImageNtHeaders)
    {
        LOG("ImageNtHeader failed");
        return NULL;
    }
    DWORD imageSize = pImageNtHeaders->OptionalHeader.SizeOfImage;
    DBK_MdlUnMapMem(imageMap);
    if (0 == imageSize)
    {
        LOG("image size == 0 failed");
        return NULL;
    }

    // 读取内核映像到R3内存pUserAddr
    PVOID pUserAddr = malloc(imageSize);
    if (NULL == pUserAddr)
    {
        LOG("malloc failed");
        return NULL;
    }
    ZeroMemory(pUserAddr, imageSize);
    if (!DBK_ReadProcessMem(4, (UINT64)pUserAddr, (UINT64)pImageAddr, imageSize, true))
    {
        LOG("DBK_ReadMem failed");
        free(pUserAddr);
        return NULL;
    }

    // 遍历导出表
    ULONG dirSize = 0;
    PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData(pUserAddr, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &dirSize);
    if (NULL == pExportDir)
    {
        LOG("ImageDirectoryEntryToData failed");
        free(pUserAddr);
        return NULL;
    }
    PULONG names = (PULONG)CONVERT_RVA(pUserAddr, pExportDir->AddressOfNames);
    PUSHORT ordinals = (PUSHORT)CONVERT_RVA(pUserAddr, pExportDir->AddressOfNameOrdinals);
    PULONG functions = (PULONG)CONVERT_RVA(pUserAddr, pExportDir->AddressOfFunctions);
    PVOID pExportFunc = NULL;
    for (ULONG i = 0; i < pExportDir->NumberOfNames; ++i)
    {
        LPCSTR name = (LPCSTR)CONVERT_RVA(pUserAddr, names[i]);
        if (0 == strcmp(exportFuncName, name))
        {
            pExportFunc = CONVERT_RVA(pImageAddr, functions[ordinals[i]]);
            break;
        }
    }

    free(pUserAddr);
    return pExportFunc;
}

// 修复导入表
bool FixImports(PVOID pImageBuffer, PVOID pBaseAddress)
{
    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = NULL;
    PIMAGE_NT_HEADERS pImageNtHeaders = NULL;
    ULONG ulTemp = 0;
    ULONG ulSize = 0;
    LPSTR libName = NULL;
    PVOID pDriverAddr = NULL;
    PIMAGE_THUNK_DATA pNames = NULL;
    PIMAGE_THUNK_DATA pFuncP = NULL;
    PIMAGE_IMPORT_BY_NAME pIName = NULL;
    PVOID func = NULL;

    // 得到导入表首地址pImportDescriptor及大小ulSize
    pImageNtHeaders = ImageNtHeader(pImageBuffer);
    if (NULL == pImageNtHeaders)
    {
        LOG("ImageNtHeader failed");
        return false;
    }
    pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(pImageNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + (ULONG_PTR)pImageBuffer);
    ulSize = pImageNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;

    // 遍历导入描述符
    for (; pImportDescriptor->Name; pImportDescriptor++)
    {
        libName = (PCHAR)((ULONG_PTR)pImageBuffer + pImportDescriptor->Name);
        pDriverAddr = GetDriverAddress(ConvertCharToWString(libName).c_str());
        if (pDriverAddr)
        {
            pNames = (PIMAGE_THUNK_DATA)CONVERT_RVA(pImageBuffer, pImportDescriptor->OriginalFirstThunk);
            pFuncP = (PIMAGE_THUNK_DATA)CONVERT_RVA(pImageBuffer, pImportDescriptor->FirstThunk);
            for (; pNames->u1.ForwarderString; ++pNames, ++pFuncP)
            {
                pIName = (PIMAGE_IMPORT_BY_NAME)CONVERT_RVA(pImageBuffer, pNames->u1.AddressOfData);
                func = GetDriverExportFuncByName(pDriverAddr, pIName->Name);
                if (func)
                {
                    pFuncP->u1.Function = (ULONG_PTR)func;
                }
                else
                {
                    LOG("GetRoutineByName failed");
                    return false;
                }
            }
        }
        else
        {
            LOG("GetModuleByName failed, driver name: %s", libName);
            return false;
        }
    }

    return true;
}

// 由驱动模块地址获取到驱动入口点地址
PVOID GetDriverEntryPoint(PVOID pDriverAddress)
{
    MapMemInfo imageMap;
    if (!DBK_MdlMapMem(imageMap, 0, 0, (UINT64)pDriverAddress, 0x1000))
    {
        LOG("DBK_MapMem failed");
        return NULL;
    }
    PIMAGE_NT_HEADERS pImageNtHeaders = ImageNtHeader((PVOID)imageMap.address);
    if (NULL == pImageNtHeaders)
    {
        LOG("ImageNtHeader failed");
        DBK_MdlUnMapMem(imageMap);
        return NULL;
    }
    PVOID pDriverEntryPoint = CONVERT_RVA(pDriverAddress, pImageNtHeaders->OptionalHeader.AddressOfEntryPoint);
    DBK_MdlUnMapMem(imageMap);
    return pDriverEntryPoint;
}

// shellcode 调用IoCreateDriver来创建驱动
static BYTE shellcode_CallIoCreateDriver[] = {
    0x48, 0xB9, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11,		// mov rcx, 0x1122334455667788	第一个参数 Fun_MmGetSystemRoutineAddress fun_MmGetSystemRoutineAddress
    0x48, 0xBA, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11,		// mov rdx, 0x1122334455667788	第二个参数 PWCHAR wDriverName
    0x49, 0xB8, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11,     // mov r8,  0x1122334455667788  第三个参数 PDRIVER_INITIALIZE pDriverInitialize
    0x4C, 0x89, 0x44, 0x24, 0x18, 0x48, 0x89, 0x54, 0x24, 0x10,
    0x48, 0x89, 0x4C, 0x24, 0x08, 0x57, 0x48, 0x81, 0xEC, 0xE0,
    0x01, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00,
    0x00, 0xB8, 0x50, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24,
    0xD8, 0x00, 0x00, 0x00, 0xB8, 0x73, 0x00, 0x00, 0x00, 0x66,
    0x89, 0x84, 0x24, 0xDA, 0x00, 0x00, 0x00, 0xB8, 0x4C, 0x00,
    0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xDC, 0x00, 0x00, 0x00,
    0xB8, 0x6F, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xDE,
    0x00, 0x00, 0x00, 0xB8, 0x6F, 0x00, 0x00, 0x00, 0x66, 0x89,
    0x84, 0x24, 0xE0, 0x00, 0x00, 0x00, 0xB8, 0x6B, 0x00, 0x00,
    0x00, 0x66, 0x89, 0x84, 0x24, 0xE2, 0x00, 0x00, 0x00, 0xB8,
    0x75, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xE4, 0x00,
    0x00, 0x00, 0xB8, 0x70, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84,
    0x24, 0xE6, 0x00, 0x00, 0x00, 0xB8, 0x50, 0x00, 0x00, 0x00,
    0x66, 0x89, 0x84, 0x24, 0xE8, 0x00, 0x00, 0x00, 0xB8, 0x72,
    0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xEA, 0x00, 0x00,
    0x00, 0xB8, 0x6F, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24,
    0xEC, 0x00, 0x00, 0x00, 0xB8, 0x63, 0x00, 0x00, 0x00, 0x66,
    0x89, 0x84, 0x24, 0xEE, 0x00, 0x00, 0x00, 0xB8, 0x65, 0x00,
    0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xF0, 0x00, 0x00, 0x00,
    0xB8, 0x73, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xF2,
    0x00, 0x00, 0x00, 0xB8, 0x73, 0x00, 0x00, 0x00, 0x66, 0x89,
    0x84, 0x24, 0xF4, 0x00, 0x00, 0x00, 0xB8, 0x42, 0x00, 0x00,
    0x00, 0x66, 0x89, 0x84, 0x24, 0xF6, 0x00, 0x00, 0x00, 0xB8,
    0x79, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xF8, 0x00,
    0x00, 0x00, 0xB8, 0x50, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84,
    0x24, 0xFA, 0x00, 0x00, 0x00, 0xB8, 0x72, 0x00, 0x00, 0x00,
    0x66, 0x89, 0x84, 0x24, 0xFC, 0x00, 0x00, 0x00, 0xB8, 0x6F,
    0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xFE, 0x00, 0x00,
    0x00, 0xB8, 0x63, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24,
    0x00, 0x01, 0x00, 0x00, 0xB8, 0x65, 0x00, 0x00, 0x00, 0x66,
    0x89, 0x84, 0x24, 0x02, 0x01, 0x00, 0x00, 0xB8, 0x73, 0x00,
    0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0x04, 0x01, 0x00, 0x00,
    0xB8, 0x73, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0x06,
    0x01, 0x00, 0x00, 0xB8, 0x49, 0x00, 0x00, 0x00, 0x66, 0x89,
    0x84, 0x24, 0x08, 0x01, 0x00, 0x00, 0xB8, 0x64, 0x00, 0x00,
    0x00, 0x66, 0x89, 0x84, 0x24, 0x0A, 0x01, 0x00, 0x00, 0x33,
    0xC0, 0x66, 0x89, 0x84, 0x24, 0x0C, 0x01, 0x00, 0x00, 0x48,
    0x8D, 0x84, 0x24, 0x30, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xF8,
    0x33, 0xC0, 0xB9, 0x10, 0x00, 0x00, 0x00, 0xF3, 0xAA, 0x48,
    0x8D, 0x84, 0x24, 0xD8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x84,
    0x24, 0xC8, 0x01, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x48,
    0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0xFF, 0x44, 0x24, 0x48, 0x48,
    0x8B, 0x84, 0x24, 0xC8, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x4C,
    0x24, 0x48, 0x66, 0x83, 0x3C, 0x48, 0x00, 0x75, 0xE7, 0x48,
    0x8B, 0x44, 0x24, 0x48, 0x48, 0xD1, 0xE0, 0x66, 0x89, 0x84,
    0x24, 0x30, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x84, 0x24, 0xD8,
    0x00, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xC0, 0x01, 0x00,
    0x00, 0x48, 0xC7, 0x44, 0x24, 0x50, 0xFF, 0xFF, 0xFF, 0xFF,
    0x48, 0xFF, 0x44, 0x24, 0x50, 0x48, 0x8B, 0x84, 0x24, 0xC0,
    0x01, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0x66, 0x83,
    0x3C, 0x48, 0x00, 0x75, 0xE7, 0x48, 0x8B, 0x44, 0x24, 0x50,
    0x48, 0x8D, 0x44, 0x00, 0x02, 0x66, 0x89, 0x84, 0x24, 0x32,
    0x01, 0x00, 0x00, 0x48, 0x8D, 0x84, 0x24, 0xD8, 0x00, 0x00,
    0x00, 0x48, 0x89, 0x84, 0x24, 0x38, 0x01, 0x00, 0x00, 0x48,
    0x8D, 0x8C, 0x24, 0x30, 0x01, 0x00, 0x00, 0xFF, 0x94, 0x24,
    0xF0, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x10, 0x01,
    0x00, 0x00, 0x48, 0x83, 0xBC, 0x24, 0x10, 0x01, 0x00, 0x00,
    0x00, 0x75, 0x0A, 0xB8, 0x01, 0x00, 0x00, 0xC0, 0xE9, 0x1E,
    0x06, 0x00, 0x00, 0x48, 0x8D, 0x84, 0x24, 0xD8, 0x00, 0x00,
    0x00, 0x48, 0x8B, 0xF8, 0x33, 0xC0, 0xB9, 0x36, 0x00, 0x00,
    0x00, 0xF3, 0xAA, 0xB8, 0x4B, 0x00, 0x00, 0x00, 0x66, 0x89,
    0x84, 0x24, 0xB8, 0x00, 0x00, 0x00, 0xB8, 0x65, 0x00, 0x00,
    0x00, 0x66, 0x89, 0x84, 0x24, 0xBA, 0x00, 0x00, 0x00, 0xB8,
    0x41, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xBC, 0x00,
    0x00, 0x00, 0xB8, 0x74, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84,
    0x24, 0xBE, 0x00, 0x00, 0x00, 0xB8, 0x74, 0x00, 0x00, 0x00,
    0x66, 0x89, 0x84, 0x24, 0xC0, 0x00, 0x00, 0x00, 0xB8, 0x61,
    0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xC2, 0x00, 0x00,
    0x00, 0xB8, 0x63, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24,
    0xC4, 0x00, 0x00, 0x00, 0xB8, 0x68, 0x00, 0x00, 0x00, 0x66,
    0x89, 0x84, 0x24, 0xC6, 0x00, 0x00, 0x00, 0xB8, 0x50, 0x00,
    0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xC8, 0x00, 0x00, 0x00,
    0xB8, 0x72, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xCA,
    0x00, 0x00, 0x00, 0xB8, 0x6F, 0x00, 0x00, 0x00, 0x66, 0x89,
    0x84, 0x24, 0xCC, 0x00, 0x00, 0x00, 0xB8, 0x63, 0x00, 0x00,
    0x00, 0x66, 0x89, 0x84, 0x24, 0xCE, 0x00, 0x00, 0x00, 0xB8,
    0x65, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xD0, 0x00,
    0x00, 0x00, 0xB8, 0x73, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84,
    0x24, 0xD2, 0x00, 0x00, 0x00, 0xB8, 0x73, 0x00, 0x00, 0x00,
    0x66, 0x89, 0x84, 0x24, 0xD4, 0x00, 0x00, 0x00, 0x33, 0xC0,
    0x66, 0x89, 0x84, 0x24, 0xD6, 0x00, 0x00, 0x00, 0x48, 0x8D,
    0x84, 0x24, 0x40, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xF8, 0x33,
    0xC0, 0xB9, 0x10, 0x00, 0x00, 0x00, 0xF3, 0xAA, 0x48, 0x8D,
    0x84, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24,
    0xD0, 0x01, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x58, 0xFF,
    0xFF, 0xFF, 0xFF, 0x48, 0xFF, 0x44, 0x24, 0x58, 0x48, 0x8B,
    0x84, 0x24, 0xD0, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24,
    0x58, 0x66, 0x83, 0x3C, 0x48, 0x00, 0x75, 0xE7, 0x48, 0x8B,
    0x44, 0x24, 0x58, 0x48, 0xD1, 0xE0, 0x66, 0x89, 0x84, 0x24,
    0x40, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x84, 0x24, 0xB8, 0x00,
    0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x80, 0x01, 0x00, 0x00,
    0x48, 0xC7, 0x44, 0x24, 0x60, 0xFF, 0xFF, 0xFF, 0xFF, 0x48,
    0xFF, 0x44, 0x24, 0x60, 0x48, 0x8B, 0x84, 0x24, 0x80, 0x01,
    0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x60, 0x66, 0x83, 0x3C,
    0x48, 0x00, 0x75, 0xE7, 0x48, 0x8B, 0x44, 0x24, 0x60, 0x48,
    0x8D, 0x44, 0x00, 0x02, 0x66, 0x89, 0x84, 0x24, 0x42, 0x01,
    0x00, 0x00, 0x48, 0x8D, 0x84, 0x24, 0xB8, 0x00, 0x00, 0x00,
    0x48, 0x89, 0x84, 0x24, 0x48, 0x01, 0x00, 0x00, 0x48, 0x8D,
    0x8C, 0x24, 0x40, 0x01, 0x00, 0x00, 0xFF, 0x94, 0x24, 0xF0,
    0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x18, 0x01, 0x00,
    0x00, 0x48, 0x83, 0xBC, 0x24, 0x18, 0x01, 0x00, 0x00, 0x00,
    0x75, 0x0A, 0xB8, 0x01, 0x00, 0x00, 0xC0, 0xE9, 0x67, 0x04,
    0x00, 0x00, 0x48, 0x8D, 0x84, 0x24, 0xB8, 0x00, 0x00, 0x00,
    0x48, 0x8B, 0xF8, 0x33, 0xC0, 0xB9, 0x20, 0x00, 0x00, 0x00,
    0xF3, 0xAA, 0xB8, 0x4B, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84,
    0x24, 0x98, 0x00, 0x00, 0x00, 0xB8, 0x65, 0x00, 0x00, 0x00,
    0x66, 0x89, 0x84, 0x24, 0x9A, 0x00, 0x00, 0x00, 0xB8, 0x44,
    0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0x9C, 0x00, 0x00,
    0x00, 0xB8, 0x65, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24,
    0x9E, 0x00, 0x00, 0x00, 0xB8, 0x74, 0x00, 0x00, 0x00, 0x66,
    0x89, 0x84, 0x24, 0xA0, 0x00, 0x00, 0x00, 0xB8, 0x61, 0x00,
    0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xA2, 0x00, 0x00, 0x00,
    0xB8, 0x63, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xA4,
    0x00, 0x00, 0x00, 0xB8, 0x68, 0x00, 0x00, 0x00, 0x66, 0x89,
    0x84, 0x24, 0xA6, 0x00, 0x00, 0x00, 0xB8, 0x50, 0x00, 0x00,
    0x00, 0x66, 0x89, 0x84, 0x24, 0xA8, 0x00, 0x00, 0x00, 0xB8,
    0x72, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xAA, 0x00,
    0x00, 0x00, 0xB8, 0x6F, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84,
    0x24, 0xAC, 0x00, 0x00, 0x00, 0xB8, 0x63, 0x00, 0x00, 0x00,
    0x66, 0x89, 0x84, 0x24, 0xAE, 0x00, 0x00, 0x00, 0xB8, 0x65,
    0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24, 0xB0, 0x00, 0x00,
    0x00, 0xB8, 0x73, 0x00, 0x00, 0x00, 0x66, 0x89, 0x84, 0x24,
    0xB2, 0x00, 0x00, 0x00, 0xB8, 0x73, 0x00, 0x00, 0x00, 0x66,
    0x89, 0x84, 0x24, 0xB4, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x66,
    0x89, 0x84, 0x24, 0xB6, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x84,
    0x24, 0x50, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xF8, 0x33, 0xC0,
    0xB9, 0x10, 0x00, 0x00, 0x00, 0xF3, 0xAA, 0x48, 0x8D, 0x84,
    0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x88,
    0x01, 0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x68, 0xFF, 0xFF,
    0xFF, 0xFF, 0x48, 0xFF, 0x44, 0x24, 0x68, 0x48, 0x8B, 0x84,
    0x24, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x68,
    0x66, 0x83, 0x3C, 0x48, 0x00, 0x75, 0xE7, 0x48, 0x8B, 0x44,
    0x24, 0x68, 0x48, 0xD1, 0xE0, 0x66, 0x89, 0x84, 0x24, 0x50,
    0x01, 0x00, 0x00, 0x48, 0x8D, 0x84, 0x24, 0x98, 0x00, 0x00,
    0x00, 0x48, 0x89, 0x84, 0x24, 0x90, 0x01, 0x00, 0x00, 0x48,
    0xC7, 0x44, 0x24, 0x70, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0xFF,
    0x44, 0x24, 0x70, 0x48, 0x8B, 0x84, 0x24, 0x90, 0x01, 0x00,
    0x00, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0x66, 0x83, 0x3C, 0x48,
    0x00, 0x75, 0xE7, 0x48, 0x8B, 0x44, 0x24, 0x70, 0x48, 0x8D,
    0x44, 0x00, 0x02, 0x66, 0x89, 0x84, 0x24, 0x52, 0x01, 0x00,
    0x00, 0x48, 0x8D, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48,
    0x89, 0x84, 0x24, 0x58, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x8C,
    0x24, 0x50, 0x01, 0x00, 0x00, 0xFF, 0x94, 0x24, 0xF0, 0x01,
    0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x28, 0x01, 0x00, 0x00,
    0x48, 0x83, 0xBC, 0x24, 0x28, 0x01, 0x00, 0x00, 0x00, 0x75,
    0x0A, 0xB8, 0x01, 0x00, 0x00, 0xC0, 0xE9, 0xB0, 0x02, 0x00,
    0x00, 0x48, 0x8D, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48,
    0x8B, 0xF8, 0x33, 0xC0, 0xB9, 0x20, 0x00, 0x00, 0x00, 0xF3,
    0xAA, 0xB8, 0x49, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x28, 0xB8, 0x6F, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x2A, 0xB8, 0x43, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x2C, 0xB8, 0x72, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x2E, 0xB8, 0x65, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x30, 0xB8, 0x61, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x32, 0xB8, 0x74, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x34, 0xB8, 0x65, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x36, 0xB8, 0x44, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x38, 0xB8, 0x72, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x3A, 0xB8, 0x69, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x3C, 0xB8, 0x76, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x3E, 0xB8, 0x65, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x40, 0xB8, 0x72, 0x00, 0x00, 0x00, 0x66, 0x89, 0x44, 0x24,
    0x42, 0x33, 0xC0, 0x66, 0x89, 0x44, 0x24, 0x44, 0x48, 0x8D,
    0x84, 0x24, 0x60, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xF8, 0x33,
    0xC0, 0xB9, 0x10, 0x00, 0x00, 0x00, 0xF3, 0xAA, 0x48, 0x8D,
    0x44, 0x24, 0x28, 0x48, 0x89, 0x84, 0x24, 0x98, 0x01, 0x00,
    0x00, 0x48, 0xC7, 0x44, 0x24, 0x78, 0xFF, 0xFF, 0xFF, 0xFF,
    0x48, 0xFF, 0x44, 0x24, 0x78, 0x48, 0x8B, 0x84, 0x24, 0x98,
    0x01, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x78, 0x66, 0x83,
    0x3C, 0x48, 0x00, 0x75, 0xE7, 0x48, 0x8B, 0x44, 0x24, 0x78,
    0x48, 0xD1, 0xE0, 0x66, 0x89, 0x84, 0x24, 0x60, 0x01, 0x00,
    0x00, 0x48, 0x8D, 0x44, 0x24, 0x28, 0x48, 0x89, 0x84, 0x24,
    0xA0, 0x01, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0x80, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0xFF, 0x84, 0x24,
    0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xA0, 0x01,
    0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00,
    0x66, 0x83, 0x3C, 0x48, 0x00, 0x75, 0xE1, 0x48, 0x8B, 0x84,
    0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x44, 0x00, 0x02,
    0x66, 0x89, 0x84, 0x24, 0x62, 0x01, 0x00, 0x00, 0x48, 0x8D,
    0x44, 0x24, 0x28, 0x48, 0x89, 0x84, 0x24, 0x68, 0x01, 0x00,
    0x00, 0x48, 0x8D, 0x8C, 0x24, 0x60, 0x01, 0x00, 0x00, 0xFF,
    0x94, 0x24, 0xF0, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24,
    0x20, 0x01, 0x00, 0x00, 0x48, 0x83, 0xBC, 0x24, 0x20, 0x01,
    0x00, 0x00, 0x00, 0x75, 0x0A, 0xB8, 0x01, 0x00, 0x00, 0xC0,
    0xE9, 0x30, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x44, 0x24, 0x28,
    0x48, 0x8B, 0xF8, 0x33, 0xC0, 0xB9, 0x1E, 0x00, 0x00, 0x00,
    0xF3, 0xAA, 0x48, 0x8D, 0x94, 0x24, 0xA8, 0x01, 0x00, 0x00,
    0xB9, 0x04, 0x00, 0x00, 0x00, 0xFF, 0x94, 0x24, 0x10, 0x01,
    0x00, 0x00, 0x89, 0x44, 0x24, 0x20, 0x83, 0x7C, 0x24, 0x20,
    0x00, 0x7D, 0x09, 0x8B, 0x44, 0x24, 0x20, 0xE9, 0xF7, 0x00,
    0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0xA8, 0x01, 0x00, 0x00,
    0xFF, 0x94, 0x24, 0x18, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x84,
    0x24, 0x70, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xF8, 0x33, 0xC0,
    0xB9, 0x10, 0x00, 0x00, 0x00, 0xF3, 0xAA, 0x48, 0x8B, 0x84,
    0x24, 0xF8, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xB0,
    0x01, 0x00, 0x00, 0x48, 0xC7, 0x84, 0x24, 0x88, 0x00, 0x00,
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0xFF, 0x84, 0x24, 0x88,
    0x00, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xB0, 0x01, 0x00,
    0x00, 0x48, 0x8B, 0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x66,
    0x83, 0x3C, 0x48, 0x00, 0x75, 0xE1, 0x48, 0x8B, 0x84, 0x24,
    0x88, 0x00, 0x00, 0x00, 0x48, 0xD1, 0xE0, 0x66, 0x89, 0x84,
    0x24, 0x70, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xF8,
    0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xB8, 0x01, 0x00,
    0x00, 0x48, 0xC7, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0xFF,
    0xFF, 0xFF, 0xFF, 0x48, 0xFF, 0x84, 0x24, 0x90, 0x00, 0x00,
    0x00, 0x48, 0x8B, 0x84, 0x24, 0xB8, 0x01, 0x00, 0x00, 0x48,
    0x8B, 0x8C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x66, 0x83, 0x3C,
    0x48, 0x00, 0x75, 0xE1, 0x48, 0x8B, 0x84, 0x24, 0x90, 0x00,
    0x00, 0x00, 0x48, 0x8D, 0x44, 0x00, 0x02, 0x66, 0x89, 0x84,
    0x24, 0x72, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xF8,
    0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x78, 0x01, 0x00,
    0x00, 0x48, 0x8B, 0x94, 0x24, 0x00, 0x02, 0x00, 0x00, 0x48,
    0x8D, 0x8C, 0x24, 0x70, 0x01, 0x00, 0x00, 0xFF, 0x94, 0x24,
    0x20, 0x01, 0x00, 0x00, 0x89, 0x44, 0x24, 0x20, 0xFF, 0x94,
    0x24, 0x28, 0x01, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x20, 0x48,
    0x81, 0xC4, 0xE0, 0x01, 0x00, 0x00, 0x5F, 0xC3
};

// shellcode 直接跳转到DriverEntry
static BYTE shellcode_JmpDriverEntry[] = {
    0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,		// jmp ......	跳转到 DriverEntry
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

// 加载自己的未签名驱动
bool DBK_LoadMyDriver(LoadType loadType, const wchar_t* driverFilePath, const wchar_t* driverName)
{
    bool result = true;

    PVOID pFileBuffer = NULL;
    size_t fileBufferLen = 0;

    PVOID pKernelImage = NULL;
    PVOID pUserImage = NULL;
    size_t imageSize = 0;

    PVOID pKernelShellcode = NULL;
    PVOID pUserShellcode = NULL;
    size_t shellcodeSize = 0;

    do
    {
        // 构造映像内存Image
        // 1.将文件映射到内存pFileBuffer，文件大小为fileBufferLen，映像大小为imageSize
        pFileBuffer = LoadFileToMemory(driverFilePath, fileBufferLen);
        if (NULL == pFileBuffer || 0 == fileBufferLen)
        {
            LOG("LoadFileToMemory failed");
            result = false;
            break;
        }
        PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((ULONG_PTR)pFileBuffer + ((PIMAGE_DOS_HEADER)pFileBuffer)->e_lfanew);
        if (NULL == pImageNtHeaders)
        {
            LOG("RtlImageNtHeader failed");
            result = false;
            break;
        }
        imageSize = pImageNtHeaders->OptionalHeader.SizeOfImage;
        // 2.分配R0映像内存pKernelImage
        pKernelImage = (PVOID)DBK_AllocNonPagedMem(imageSize);
        if (NULL == pKernelImage)
        {
            LOG("DBK_AllocNonPagedMem failed");
            result = false;
            break;
        }
        // 3.分配R3映像内存pUserImage
        pUserImage = malloc(imageSize);
        if (NULL == pUserImage)
        {
            LOG("malloc failed");
            result = false;
            break;
        }
        // 4.拷贝NT头和各个Section
        memcpy(pUserImage, pFileBuffer, pImageNtHeaders->OptionalHeader.SizeOfHeaders);
        PIMAGE_SECTION_HEADER pImageSectionHeader = (PIMAGE_SECTION_HEADER)(((PIMAGE_DOS_HEADER)pFileBuffer)->e_lfanew + sizeof(IMAGE_NT_HEADERS) + (ULONG_PTR)pFileBuffer);
        for (ULONG i = 0; i < pImageNtHeaders->FileHeader.NumberOfSections; ++i)
        {
            memcpy((PCHAR)pUserImage + pImageSectionHeader[i].VirtualAddress, (PCHAR)pFileBuffer + pImageSectionHeader[i].PointerToRawData, pImageSectionHeader[i].SizeOfRawData);
        }
        // 5.进行重定位
        if (!FixRelocation(pUserImage, pKernelImage))
        {
            LOG("FixRelocation failed");
            result = false;
            break;
        }
        // 6.修复导入表
        if (!FixImports(pUserImage, pKernelImage))
        {
            LOG("FindImports failed");
            result = false;
            break;
        }
        // 7.将R3映像内存pUserImage拷贝到R0映像内存pKernelImage中去
        if (!DBK_WriteProcessMem(4, (UINT64)pKernelImage, (UINT64)pUserImage, imageSize))
        {
            LOG("DBK_WriteMem failed");
            result = false;
            break;
        }

        // 获取驱动起始地址
        UINT64 pDriverInitialize = (UINT64)CONVERT_RVA(pKernelImage, pImageNtHeaders->OptionalHeader.AddressOfEntryPoint);

        if (LoadByIoCreateDriver == loadType)
        {
            // 构造调用IoCreateDriver来创建驱动的shellcode
            // 1.shellcode大小为shellcodeSize
            shellcodeSize = sizeof(shellcode_CallIoCreateDriver) + MAX_PATH * sizeof(WCHAR);
            // 2.分配R0的shellcode内存pKernelShellcode
            pKernelShellcode = (PVOID)DBK_AllocNonPagedMem((ULONG)shellcodeSize);
            if (NULL == pKernelShellcode)
            {
                LOG("DBK_AllocNonPagedMem failed");
                result = false;
                break;
            }
            // 3.分配R3的shellcode内存pUserShellcode
            pUserShellcode = malloc(shellcodeSize);
            if (NULL == pUserShellcode)
            {
                LOG("malloc failed");
                result = false;
                break;
            }
            ZeroMemory(pUserShellcode, shellcodeSize);
            // 4.获取MmGetSystemRoutineAddress地址
            UINT64 fun_MmGetSystemRoutineAddress = DBK_GetKernelFuncAddress(L"MmGetSystemRoutineAddress");
            if (0 == fun_MmGetSystemRoutineAddress)
            {
                LOG("DBK_GetKernelFuncAddress failed");
                result = false;
                break;
            }
            // 4.修改shellcode
            memcpy(pUserShellcode, shellcode_CallIoCreateDriver, sizeof(shellcode_CallIoCreateDriver));
            wcscpy((wchar_t*)((PCHAR)pUserShellcode + sizeof(shellcode_CallIoCreateDriver)), driverName);				// 拷贝驱动名驱动名
            *((PUINT64)((PCHAR)pUserShellcode + 2)) = fun_MmGetSystemRoutineAddress;	// 设置第一个参数 Fun_MmGetSystemRoutineAddress fun_MmGetSystemRoutineAddress
            *((PUINT64)((PCHAR)pUserShellcode + 12)) = (UINT64)pKernelShellcode + sizeof(shellcode_CallIoCreateDriver); // 设置第二个参数 PWCHAR wDriverName
            *((PUINT64)((PCHAR)pUserShellcode + 22)) = pDriverInitialize;				// 设置第三个参数 PDRIVER_INITIALIZE pDriverInitialize
            // 5.将R3的shellcode拷贝到R0的shellcode中去
            if (!DBK_WriteProcessMem(4, (UINT64)pKernelShellcode, (UINT64)pUserShellcode, shellcodeSize))
            {
                LOG("DBK_WriteMem failed");
                result = false;
                break;
            }
        }
        else if (LoadByShellcode == loadType)
        {
            // 构造直接调用DriverEntry的shellcode
            shellcodeSize = sizeof(shellcode_JmpDriverEntry);
            pKernelShellcode = (PVOID)DBK_AllocNonPagedMem(shellcodeSize);
            if (NULL == pKernelShellcode)
            {
                LOG("DBK_AllocNonPagedMem failed");
                result = false;
                break;
            }
            pUserShellcode = malloc(shellcodeSize);
            if (NULL == pUserShellcode)
            {
                LOG("malloc failed");
                result = false;
                break;
            }
            memcpy(pUserShellcode, shellcode_JmpDriverEntry, shellcodeSize);
            *((PUINT64)((PCHAR)pUserShellcode + 6)) = pDriverInitialize;
            if (!DBK_WriteProcessMem(4, (UINT64)pKernelShellcode, (UINT64)pUserShellcode, shellcodeSize))
            {
                LOG("DBK_WriteMem failed");
                result = false;
                break;
            }
        }

        // 执行shellcode
        LOG("Prepare To Execute Kernel Shellcode");
        if (!DBK_ExecuteCode((UINT64)pKernelShellcode))
        {
            LOG("DBK_ExecuteCode failed");
            result = false;
            break;
        }
        LOG("Execute Kernel Shellcode End");
    } while (0);

    if (pUserShellcode)
    {
        free(pUserShellcode);
    }
    if (pKernelShellcode)
    {
        DBK_FreeNonPagedMem((UINT64)pKernelShellcode);
    }
    if (pUserImage)
    {
        free(pUserImage);
    }
    /*
    if (pKernelImage)
    {
        DBK_FreeNonPagedMem((UINT64)pKernelImage);
    }
    */
    if (pFileBuffer)
    {
        free(pFileBuffer);
    }
    return result;
}
